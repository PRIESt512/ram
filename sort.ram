<input> 4 9 4 5 7

read 3 ; N
;-----------

load =5 ;сдвиг на 5 регистров вперед, начиная с 5 регистра пишем переменные из входной ленты
store 1
;-----------
load =1 ; счетчик (i) для выполнения массива
store 2
;-----------
loop_input: ;читаем массив в память с учетом сдвига регистров для хранения вспомогательных переменных
  read *1 ;записываем в регистр по номеру регистра, который хранится в 1 регистре
;-----------
  load 1 ;инкремент регистра для следующей записи элемента массива
  add =1
  store 1
;-----------
  load 2 ; i++
  add =1
  store 2
;-----------
  sub 3 ; i - N 
  JGTZ continue_one ; выполняем массив, пока не окончатся входной массив
  jmp loop_input
;-----------
continue_one:

load 3 ; к размерности входного массива добавляем 5, чтобы учесть карту регистров
add =5
store 3

load 3 ; проверка условия для i
sub =1
store 4
;load =5 ; переменная константа для хранения сдвига области регистров, где начинаются пользовательские данные, начинаем с 5, чтобы i начинался с 0 (некая эмуляция индексации массива)
;store 3
;-----------
load =5 ; в 1 регистре храним i (начиная с 5)
store 1
;-----------

loop_sort_i:
  load 1  ; во 2 регистре храним k (начиная с i+1)
  add =1
  store 2

  loop_sort_k:

    load *1 ; в R0 загружаем первый элемент для сравнения
    sub *2 ; вычитаем второй элемент для сравнения
    JGTZ swap
    JMP condition_loop_sort_k

    swap: ; (перестановка без использования 3 переменной)
      load *1 ; a = a + b
      add *2
      store *1
 
      sub *2 ; b = a - b
      store *2

      load *1 ; a = a - b
      sub *2
      store *1

    condition_loop_sort_k:
      load 2
      add =1 ; k++
      store 2
      sub 3
      JZ condition_loop_sort_i
      JMP loop_sort_k
    
  condition_loop_sort_i:
    load 1
    add =1 ; i++
    store 1
    sub 4
    JZ continue_two
    JMP loop_sort_i

continue_two:

halt